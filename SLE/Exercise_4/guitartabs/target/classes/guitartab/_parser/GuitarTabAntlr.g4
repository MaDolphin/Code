/* generated by template parser.Parser*/


/* generated by template parser.ParserHeader*/
grammar GuitarTabAntlr;
@parser::header {
package guitartab._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package guitartab._parser;
}
options {
superClass=MCParser;
}

@parser::members

{

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for Digit
private String convertDigit(Token t)  {
    return t.getText();
}

  // convert function for Linebreak
private String convertLinebreak(Token t)  {
    return t.getText();
}

}

/* generated by template parser.LexerMember*/


@lexer::members {



private GuitarTabAntlrParser _monticore_parser;

protected GuitarTabAntlrParser getCompiler() {
   return _monticore_parser;
}

public void setMCParser(GuitarTabAntlrParser in) {
  this._monticore_parser = in;
}

protected void storeComment(){
  if (getCompiler() != null) {
    de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
    de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
    _comment.set_SourcePositionStart(startPos);
    _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
    getCompiler().addComment(_comment);
  }
}
}


  
 // Start of 'ASTClassProd Tab'


tab_eof returns [guitartab._ast.ASTTab ret = null] :
  tmp = tab {$ret = $tmp.ret;} EOF ;


  tab returns [guitartab._ast.ASTTab ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
guitartab._ast.ASTTab _aNode = null;
_aNode=guitartab._ast.GuitarTabNodeFactory.createASTTab();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
   tmp0=comment{addToIteratedAttributeIfNotNull(_aNode.getCommentList(), _localctx.tmp0.ret);}  
  
  |
   tmp1=sixStrings{addToIteratedAttributeIfNotNull(_aNode.getSixStringsList(), _localctx.tmp1.ret);}  
  
  |
  (tmp2=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp2));}

  ) 
  
  
)*
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Comment'


comment_eof returns [guitartab._ast.ASTComment ret = null] :
  tmp = comment {$ret = $tmp.ret;} EOF ;


  comment returns [guitartab._ast.ASTComment ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
guitartab._ast.ASTComment _aNode = null;
_aNode=guitartab._ast.GuitarTabNodeFactory.createASTComment();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal ['
LBRACK// End of 'ASTTerminal'

  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getNameList(), convertName($tmp0));}

  ) 
  
  |
  (tmp1=WS{ addToIteratedAttributeIfNotNull(_aNode.getWSList(), convertWS($tmp1));}

  ) 
  
  
)*
  
 // Start of 'ASTTerminal ]'
RBRACK// End of 'ASTTerminal'

  (tmp2=Linebreak{_aNode.setLinebreak(convertLinebreak($tmp2));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SixStrings'


sixStrings_eof returns [guitartab._ast.ASTSixStrings ret = null] :
  tmp = sixStrings {$ret = $tmp.ret;} EOF ;


  sixStrings returns [guitartab._ast.ASTSixStrings ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
guitartab._ast.ASTSixStrings _aNode = null;
_aNode=guitartab._ast.GuitarTabNodeFactory.createASTSixStrings();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal e'
'e'// End of 'ASTTerminal'

   tmp0=guitarString{addToIteratedAttributeIfNotNull(_aNode.getGuitarStringList(), _localctx.tmp0.ret);}  
  
  (tmp1=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal B'
'B'// End of 'ASTTerminal'

   tmp2=guitarString{addToIteratedAttributeIfNotNull(_aNode.getGuitarStringList(), _localctx.tmp2.ret);}  
  
  (tmp3=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp3));}

  ) 
  
  
 // Start of 'ASTTerminal G'
'G'// End of 'ASTTerminal'

   tmp4=guitarString{addToIteratedAttributeIfNotNull(_aNode.getGuitarStringList(), _localctx.tmp4.ret);}  
  
  (tmp5=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp5));}

  ) 
  
  
 // Start of 'ASTTerminal D'
'D'// End of 'ASTTerminal'

   tmp6=guitarString{addToIteratedAttributeIfNotNull(_aNode.getGuitarStringList(), _localctx.tmp6.ret);}  
  
  (tmp7=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp7));}

  ) 
  
  
 // Start of 'ASTTerminal A'
'A'// End of 'ASTTerminal'

   tmp8=guitarString{addToIteratedAttributeIfNotNull(_aNode.getGuitarStringList(), _localctx.tmp8.ret);}  
  
  (tmp9=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp9));}

  ) 
  
  
 // Start of 'ASTTerminal E'
'E'// End of 'ASTTerminal'

   tmp10=guitarString{addToIteratedAttributeIfNotNull(_aNode.getGuitarStringList(), _localctx.tmp10.ret);}  
  
  (
  
  (tmp11=Linebreak{ addToIteratedAttributeIfNotNull(_aNode.getLinebreakList(), convertLinebreak($tmp11));}

  ) 
  
  
 // Start of 'ASTTerminal L'
'L'// End of 'ASTTerminal'

   tmp12=lengthLine{_aNode.setLengthLine(_localctx.tmp12.ret);}  
  
  
)?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd GuitarString'


guitarString_eof returns [guitartab._ast.ASTGuitarString ret = null] :
  tmp = guitarString {$ret = $tmp.ret;} EOF ;


  guitarString returns [guitartab._ast.ASTGuitarString ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
guitartab._ast.ASTGuitarString _aNode = null;
_aNode=guitartab._ast.GuitarTabNodeFactory.createASTGuitarString();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal |'
PIPE// End of 'ASTTerminal'

  (
  
  (tmp0=Digit{ addToIteratedAttributeIfNotNull(_aNode.getContentList(), convertDigit($tmp0));}

  ) 
  
  |
  
 // Start of 'ASTTerminal -'
MINUS{_aNode.getContentList().add("-");}// End of 'ASTTerminal'

  
)*
  
 // Start of 'ASTTerminal |'
PIPE// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd LengthLine'


lengthLine_eof returns [guitartab._ast.ASTLengthLine ret = null] :
  tmp = lengthLine {$ret = $tmp.ret;} EOF ;


  lengthLine returns [guitartab._ast.ASTLengthLine ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
guitartab._ast.ASTLengthLine _aNode = null;
_aNode=guitartab._ast.GuitarTabNodeFactory.createASTLengthLine();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal |'
PIPE// End of 'ASTTerminal'

  (
  
  (tmp0=Digit{ addToIteratedAttributeIfNotNull(_aNode.getContentList(), convertDigit($tmp0));}

  ) 
  
  |
  
 // Start of 'ASTTerminal -'
MINUS{_aNode.getContentList().add("-");}// End of 'ASTTerminal'

  
)*
  
 // Start of 'ASTTerminal |'
PIPE// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'


 
  LBRACK : '[';
  PIPE : '|';
  RBRACK : ']';
  MINUS : '-';
 
  
 // Start of 'ASTLexProd Digit'
Digit 
  
:
  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Linebreak'
Linebreak 
  
:
  
   NEWLINE 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
  {_input.LA(2) != '/'}?
  '*' 
  |
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {storeComment();

}->skip
;// End of 'ASTLexProd'


