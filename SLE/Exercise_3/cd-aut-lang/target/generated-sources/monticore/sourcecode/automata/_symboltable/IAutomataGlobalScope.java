/* generated from model Automata */
/* generated by template core.Interface*/

/* (c) https://github.com/MontiCore/monticore */
package automata._symboltable;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;


 public  interface IAutomataGlobalScope extends automata._symboltable.IAutomataScope,de.monticore.symboltable.IGlobalScope {



  /* generated by template core.Method*/
 abstract  public  AutomataLanguage getAutomataLanguage () ;
  /* generated by template core.Method*/
 abstract  public  void cache (String calculatedModelName) ;
  default /* generated by template core.Method*/
 public  boolean checkIfContinueAsSubScope (String symbolName)  {
      return false;
}

  /* generated by template core.Method*/
 abstract  public  boolean continueWithModelLoader (String calculatedModelName,AutomataModelLoader modelLoader) ;
  default /* generated by template core.Method*/
 public  IAutomataGlobalScope getRealThis ()  {
      return this;
}

  default /* generated by template core.Method*/
 public  List<automata._symboltable.AutomatonSymbol> resolveAutomatonMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<automata._symboltable.AutomatonSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<automata._symboltable.AutomatonSymbol> resolvedSymbol = resolveAutomatonDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForAutomaton(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveAutomatonDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isAutomatonSymbolsAlreadyResolved()){
    setAutomatonSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedAutomaton(foundSymbols, name, modifier, predicate));
  }
  setAutomatonSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<automata._symboltable.AutomatonSymbol> resolveAdaptedAutomaton (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<automata._symboltable.AutomatonSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForAutomaton (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  AutomataModelLoader modelLoader = getAutomataLanguage().getModelLoader();
  Set<String> calculatedModelNames = getAutomataLanguage().calculateModelNamesForAutomaton(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        AutomataGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeSymbol> resolveTypeMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.TypeSymbol> resolvedSymbol = resolveTypeDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForType(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveTypeDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isTypeSymbolsAlreadyResolved()){
    setTypeSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedType(foundSymbols, name, modifier, predicate));
  }
  setTypeSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeSymbol> resolveAdaptedType (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForType (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  AutomataModelLoader modelLoader = getAutomataLanguage().getModelLoader();
  Set<String> calculatedModelNames = getAutomataLanguage().calculateModelNamesForType(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        AutomataGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> resolveTypeVarMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> resolvedSymbol = resolveTypeVarDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForTypeVar(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveTypeVarDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isTypeVarSymbolsAlreadyResolved()){
    setTypeVarSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedTypeVar(foundSymbols, name, modifier, predicate));
  }
  setTypeVarSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> resolveAdaptedTypeVar (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForTypeVar (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  AutomataModelLoader modelLoader = getAutomataLanguage().getModelLoader();
  Set<String> calculatedModelNames = getAutomataLanguage().calculateModelNamesForTypeVar(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        AutomataGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.FieldSymbol> resolveFieldMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.FieldSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.FieldSymbol> resolvedSymbol = resolveFieldDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForField(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveFieldDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isFieldSymbolsAlreadyResolved()){
    setFieldSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedField(foundSymbols, name, modifier, predicate));
  }
  setFieldSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.FieldSymbol> resolveAdaptedField (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.FieldSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForField (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  AutomataModelLoader modelLoader = getAutomataLanguage().getModelLoader();
  Set<String> calculatedModelNames = getAutomataLanguage().calculateModelNamesForField(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        AutomataGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.MethodSymbol> resolveMethodMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.MethodSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.MethodSymbol> resolvedSymbol = resolveMethodDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForMethod(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveMethodDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isMethodSymbolsAlreadyResolved()){
    setMethodSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedMethod(foundSymbols, name, modifier, predicate));
  }
  setMethodSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.MethodSymbol> resolveAdaptedMethod (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.MethodSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForMethod (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  AutomataModelLoader modelLoader = getAutomataLanguage().getModelLoader();
  Set<String> calculatedModelNames = getAutomataLanguage().calculateModelNamesForMethod(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        AutomataGlobalScope.class.getSimpleName());
    }
  }
}

}
