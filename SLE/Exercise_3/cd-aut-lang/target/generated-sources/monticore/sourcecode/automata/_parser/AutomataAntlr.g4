/* generated by template parser.Parser*/


/* generated by template parser.ParserHeader*/
grammar AutomataAntlr;
@parser::header {
package automata._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package automata._parser;
}
options {
superClass=MCParser;
}

@parser::members

{

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

}

/* generated by template parser.LexerMember*/


@lexer::members {



private AutomataAntlrParser _monticore_parser;

protected AutomataAntlrParser getCompiler() {
   return _monticore_parser;
}

public void setMCParser(AutomataAntlrParser in) {
  this._monticore_parser = in;
}

protected void storeComment(){
  if (getCompiler() != null) {
    de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
    de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
    _comment.set_SourcePositionStart(startPos);
    _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
    getCompiler().addComment(_comment);
  }
}
}


  
 // Start of 'ASTClassProd MCQualifiedName'


mCQualifiedName_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ret = null] :
  tmp = mCQualifiedName {$ret = $tmp.ret;} EOF ;


  mCQualifiedName returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCQualifiedName();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getPartList(), convertName($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getPartList(), convertName($tmp1));}

  ) 
  
  
)*
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCImportStatement'


mCImportStatement_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ret = null] :
  tmp = mCImportStatement {$ret = $tmp.ret;} EOF ;


  mCImportStatement returns [de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCImportStatement _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCImportStatement();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal import'
'import'// End of 'ASTTerminal'

   tmp0=mCQualifiedName{_aNode.setMCQualifiedName(_localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(STAR{
_aNode.setStar(true);
})// End of 'ASTConstantGroup'

  
)?
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCPrimitiveType'


mCPrimitiveType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ret = null] :
  tmp = mCPrimitiveType {$ret = $tmp.ret;} EOF ;


  mCPrimitiveType returns [de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCPrimitiveType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
('boolean'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.BOOLEAN);
}|
'byte'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.BYTE);
}|
'short'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.SHORT);
}|
'int'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.INT);
}|
'long'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.LONG);
}|
'char'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.CHAR);
}|
'float'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.FLOAT);
}|
'double'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.DOUBLE);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCQualifiedType'


mCQualifiedType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ret = null] :
  tmp = mCQualifiedType {$ret = $tmp.ret;} EOF ;


  mCQualifiedType returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCQualifiedType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCQualifiedName{_aNode.setMCQualifiedName(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCReturnType'


mCReturnType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCReturnType ret = null] :
  tmp = mCReturnType {$ret = $tmp.ret;} EOF ;


  mCReturnType returns [de.monticore.types.mcbasictypes._ast.ASTMCReturnType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCReturnType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCReturnType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCVoidType{_aNode.setMCVoidType(_localctx.tmp0.ret);}  
  
  |
   tmp1=mCType{_aNode.setMCType(_localctx.tmp1.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCVoidType'


mCVoidType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCVoidType ret = null] :
  tmp = mCVoidType {$ret = $tmp.ret;} EOF ;


  mCVoidType returns [de.monticore.types.mcbasictypes._ast.ASTMCVoidType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCVoidType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCVoidType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal void'
'void'// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Automaton'


automaton_eof returns [automata._ast.ASTAutomaton ret = null] :
  tmp = automaton {$ret = $tmp.ret;} EOF ;


  automaton returns [automata._ast.ASTAutomaton ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
automata._ast.ASTAutomaton _aNode = null;
_aNode=automata._ast.AutomataNodeFactory.createASTAutomaton();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
   tmp0=mCImportStatement{addToIteratedAttributeIfNotNull(_aNode.getMCImportStatementList(), _localctx.tmp0.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal automata'
'automata'// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal {'
LCURLY// End of 'ASTTerminal'

  (
  
   tmp2=state{addToIteratedAttributeIfNotNull(_aNode.getStateList(), _localctx.tmp2.ret);}  
  
  |
   tmp3=transition{addToIteratedAttributeIfNotNull(_aNode.getTransitionList(), _localctx.tmp3.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
RCURLY// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd State'


state_eof returns [automata._ast.ASTState ret = null] :
  tmp = state {$ret = $tmp.ret;} EOF ;


  state returns [automata._ast.ASTState ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
automata._ast.ASTState _aNode = null;
_aNode=automata._ast.AutomataNodeFactory.createASTState();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal state'
'state'// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  (
  
  (
  
  
 // Start of 'ASTTerminal <<'
LTLT// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
('initial'{
_aNode.setInitial(true);
})// End of 'ASTConstantGroup'

  
 // Start of 'ASTTerminal >>'
GTGT// End of 'ASTTerminal'

  
)
  |
  (
  
  
 // Start of 'ASTTerminal <<'
LTLT// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
('final'{
_aNode.setFinal(true);
})// End of 'ASTConstantGroup'

  
 // Start of 'ASTTerminal >>'
GTGT// End of 'ASTTerminal'

  
)
  
)*
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Transition'


transition_eof returns [automata._ast.ASTTransition ret = null] :
  tmp = transition {$ret = $tmp.ret;} EOF ;


  transition returns [automata._ast.ASTTransition ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
automata._ast.ASTTransition _aNode = null;
_aNode=automata._ast.AutomataNodeFactory.createASTTransition();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setFrom(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal -'
MINUS// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setInput(convertName($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  (tmp2=Name{_aNode.setTo(convertName($tmp2));}

  ) 
  
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'


  
 // Start of 'Type'


type_eof returns [de.monticore.types.typesymbols._ast.ASTType ret = null] :
  tmp = type {$ret = $tmp.ret;} EOF ;


  type
   returns [de.monticore.types.typesymbols._ast.ASTType ret]
  : 
  ;
  
 // Start of 'TypeVar'


typeVar_eof returns [de.monticore.types.typesymbols._ast.ASTTypeVar ret = null] :
  tmp = typeVar {$ret = $tmp.ret;} EOF ;


  typeVar
   returns [de.monticore.types.typesymbols._ast.ASTTypeVar ret]
  : 
  ;
  
 // Start of 'Field'


field_eof returns [de.monticore.types.typesymbols._ast.ASTField ret = null] :
  tmp = field {$ret = $tmp.ret;} EOF ;


  field
   returns [de.monticore.types.typesymbols._ast.ASTField ret]
  : 
  ;
  
 // Start of 'Method'


method_eof returns [de.monticore.types.typesymbols._ast.ASTMethod ret = null] :
  tmp = method {$ret = $tmp.ret;} EOF ;


  method
   returns [de.monticore.types.typesymbols._ast.ASTMethod ret]
  : 
  ;
  
 // Start of 'MCType'


mCType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCType ret = null] :
  tmp = mCType {$ret = $tmp.ret;} EOF ;


  mCType
   returns [de.monticore.types.mcbasictypes._ast.ASTMCType ret]
  : 
  
  tmp3=mCPrimitiveType
{$ret=$tmp3.ret;}
  |
  tmp4=mCObjectType
{$ret=$tmp4.ret;}
  ;
  
 // Start of 'MCObjectType'


mCObjectType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCObjectType ret = null] :
  tmp = mCObjectType {$ret = $tmp.ret;} EOF ;


  mCObjectType
   returns [de.monticore.types.mcbasictypes._ast.ASTMCObjectType ret]
  : 
  
  tmp5=mCQualifiedType
{$ret=$tmp5.ret;}
  ;
 
  LTLT : '<<';
  GTGT : '>>';
  STAR : '*';
  SEMI : ';';
  LCURLY : '{';
  RCURLY : '}';
  MINUS : '-';
  POINT : '.';
  GT : '>';
 
  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
  {_input.LA(2) != '/'}?
  '*' 
  |
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {storeComment();

}->skip
;// End of 'ASTLexProd'


