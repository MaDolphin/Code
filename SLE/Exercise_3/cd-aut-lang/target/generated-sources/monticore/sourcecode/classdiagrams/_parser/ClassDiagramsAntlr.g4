/* generated by template parser.Parser*/


/* generated by template parser.ParserHeader*/
grammar ClassDiagramsAntlr;
@parser::header {
package classdiagrams._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package classdiagrams._parser;
}
options {
superClass=MCParser;
}

@parser::members

{

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for Digits
private String convertDigits(Token t)  {
    return t.getText();
}

  // convert function for Digit
private String convertDigit(Token t)  {
    return t.getText();
}

  // convert function for Char
private String convertChar(Token t)  {
    return t.getText();
}

  // convert function for SingleCharacter
private String convertSingleCharacter(Token t)  {
    return t.getText();
}

  // convert function for String
private String convertString(Token t)  {
    return t.getText();
}

  // convert function for StringCharacters
private String convertStringCharacters(Token t)  {
    return t.getText();
}

  // convert function for StringCharacter
private String convertStringCharacter(Token t)  {
    return t.getText();
}

  // convert function for EscapeSequence
private String convertEscapeSequence(Token t)  {
    return t.getText();
}

  // convert function for OctalEscape
private String convertOctalEscape(Token t)  {
    return t.getText();
}

  // convert function for UnicodeEscape
private String convertUnicodeEscape(Token t)  {
    return t.getText();
}

  // convert function for ZeroToThree
private String convertZeroToThree(Token t)  {
    return t.getText();
}

  // convert function for HexDigit
private String convertHexDigit(Token t)  {
    return t.getText();
}

  // convert function for OctalDigit
private String convertOctalDigit(Token t)  {
    return t.getText();
}

}

/* generated by template parser.LexerMember*/


@lexer::members {



private ClassDiagramsAntlrParser _monticore_parser;

protected ClassDiagramsAntlrParser getCompiler() {
   return _monticore_parser;
}

public void setMCParser(ClassDiagramsAntlrParser in) {
  this._monticore_parser = in;
}

protected void storeComment(){
  if (getCompiler() != null) {
    de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
    de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
    _comment.set_SourcePositionStart(startPos);
    _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
    getCompiler().addComment(_comment);
  }
}
}


  
 // Start of 'ASTClassProd NullLiteral'


nullLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ret = null] :
  tmp = nullLiteral {$ret = $tmp.ret;} EOF ;


  nullLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTNullLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTNullLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal null'
'null'// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BooleanLiteral'


booleanLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ret = null] :
  tmp = booleanLiteral {$ret = $tmp.ret;} EOF ;


  booleanLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBooleanLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
('true'{
_aNode.setSource(de.monticore.literals.mccommonliterals._ast.ASTConstantsMCCommonLiterals.TRUE);
}|
'false'{
_aNode.setSource(de.monticore.literals.mccommonliterals._ast.ASTConstantsMCCommonLiterals.FALSE);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CharLiteral'


charLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ret = null] :
  tmp = charLiteral {$ret = $tmp.ret;} EOF ;


  charLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTCharLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTCharLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Char{_aNode.setSource(convertChar($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd StringLiteral'


stringLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ret = null] :
  tmp = stringLiteral {$ret = $tmp.ret;} EOF ;


  stringLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTStringLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTStringLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=String{_aNode.setSource(convertString($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd NatLiteral'


natLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ret = null] :
  tmp = natLiteral {$ret = $tmp.ret;} EOF ;


  natLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTNatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTNatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedNatLiteral'


signedNatLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ret = null] :
  tmp = signedNatLiteral {$ret = $tmp.ret;} EOF ;


  signedNatLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedNatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BasicLongLiteral'


basicLongLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ret = null] :
  tmp = basicLongLiteral {$ret = $tmp.ret;} EOF ;


  basicLongLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBasicLongLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  {is("l","L")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedBasicLongLiteral'


signedBasicLongLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ret = null] :
  tmp = signedBasicLongLiteral {$ret = $tmp.ret;} EOF ;


  signedBasicLongLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedBasicLongLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  {is("l","L")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BasicFloatLiteral'


basicFloatLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ret = null] :
  tmp = basicFloatLiteral {$ret = $tmp.ret;} EOF ;


  basicFloatLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBasicFloatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  (tmp2=Name{_aNode.setName(convertName($tmp2));}

  ) 
  
  {is("f","F")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedBasicFloatLiteral'


signedBasicFloatLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ret = null] :
  tmp = signedBasicFloatLiteral {$ret = $tmp.ret;} EOF ;


  signedBasicFloatLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedBasicFloatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  (tmp2=Name{_aNode.setName(convertName($tmp2));}

  ) 
  
  {is("f","F")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BasicDoubleLiteral'


basicDoubleLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ret = null] :
  tmp = basicDoubleLiteral {$ret = $tmp.ret;} EOF ;


  basicDoubleLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBasicDoubleLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedBasicDoubleLiteral'


signedBasicDoubleLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ret = null] :
  tmp = signedBasicDoubleLiteral {$ret = $tmp.ret;} EOF ;


  signedBasicDoubleLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedBasicDoubleLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCQualifiedName'


mCQualifiedName_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ret = null] :
  tmp = mCQualifiedName {$ret = $tmp.ret;} EOF ;


  mCQualifiedName returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCQualifiedName _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCQualifiedName();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getPartList(), convertName($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getPartList(), convertName($tmp1));}

  ) 
  
  
)*
  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCImportStatement'


mCImportStatement_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ret = null] :
  tmp = mCImportStatement {$ret = $tmp.ret;} EOF ;


  mCImportStatement returns [de.monticore.types.mcbasictypes._ast.ASTMCImportStatement ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCImportStatement _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCImportStatement();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal import'
'import'// End of 'ASTTerminal'

   tmp0=mCQualifiedName{_aNode.setMCQualifiedName(_localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
(STAR{
_aNode.setStar(true);
})// End of 'ASTConstantGroup'

  
)?
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCPrimitiveType'


mCPrimitiveType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ret = null] :
  tmp = mCPrimitiveType {$ret = $tmp.ret;} EOF ;


  mCPrimitiveType returns [de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCPrimitiveType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCPrimitiveType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
('boolean'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.BOOLEAN);
}|
'byte'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.BYTE);
}|
'short'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.SHORT);
}|
'int'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.INT);
}|
'long'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.LONG);
}|
'char'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.CHAR);
}|
'float'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.FLOAT);
}|
'double'{
_aNode.setPrimitive(de.monticore.types.mcbasictypes._ast.ASTConstantsMCBasicTypes.DOUBLE);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCQualifiedType'


mCQualifiedType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ret = null] :
  tmp = mCQualifiedType {$ret = $tmp.ret;} EOF ;


  mCQualifiedType returns [de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCQualifiedType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCQualifiedType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCQualifiedName{_aNode.setMCQualifiedName(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCReturnType'


mCReturnType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCReturnType ret = null] :
  tmp = mCReturnType {$ret = $tmp.ret;} EOF ;


  mCReturnType returns [de.monticore.types.mcbasictypes._ast.ASTMCReturnType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCReturnType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCReturnType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCVoidType{_aNode.setMCVoidType(_localctx.tmp0.ret);}  
  
  |
   tmp1=mCType{_aNode.setMCType(_localctx.tmp1.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCVoidType'


mCVoidType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCVoidType ret = null] :
  tmp = mCVoidType {$ret = $tmp.ret;} EOF ;


  mCVoidType returns [de.monticore.types.mcbasictypes._ast.ASTMCVoidType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcbasictypes._ast.ASTMCVoidType _aNode = null;
_aNode=de.monticore.types.mcbasictypes._ast.MCBasicTypesNodeFactory.createASTMCVoidType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal void'
'void'// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCListType'


mCListType_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCListType ret = null] :
  tmp = mCListType {$ret = $tmp.ret;} EOF ;


  mCListType returns [de.monticore.types.mccollectiontypes._ast.ASTMCListType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mccollectiontypes._ast.ASTMCListType _aNode = null;
_aNode=de.monticore.types.mccollectiontypes._ast.MCCollectionTypesNodeFactory.createASTMCListType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  {next("List")}?
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal <'
LT// End of 'ASTTerminal'

   tmp1=mCTypeArgument{addToIteratedAttributeIfNotNull(_aNode.getMCTypeArgumentList(), _localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCOptionalType'


mCOptionalType_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCOptionalType ret = null] :
  tmp = mCOptionalType {$ret = $tmp.ret;} EOF ;


  mCOptionalType returns [de.monticore.types.mccollectiontypes._ast.ASTMCOptionalType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mccollectiontypes._ast.ASTMCOptionalType _aNode = null;
_aNode=de.monticore.types.mccollectiontypes._ast.MCCollectionTypesNodeFactory.createASTMCOptionalType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  {next("Optional")}?
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal <'
LT// End of 'ASTTerminal'

   tmp1=mCTypeArgument{addToIteratedAttributeIfNotNull(_aNode.getMCTypeArgumentList(), _localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCMapType'


mCMapType_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCMapType ret = null] :
  tmp = mCMapType {$ret = $tmp.ret;} EOF ;


  mCMapType returns [de.monticore.types.mccollectiontypes._ast.ASTMCMapType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mccollectiontypes._ast.ASTMCMapType _aNode = null;
_aNode=de.monticore.types.mccollectiontypes._ast.MCCollectionTypesNodeFactory.createASTMCMapType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  {next("Map")}?
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal <'
LT// End of 'ASTTerminal'

   tmp1=mCTypeArgument{_aNode.setKey(_localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp2=mCTypeArgument{_aNode.setValue(_localctx.tmp2.ret);}  
  
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCSetType'


mCSetType_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCSetType ret = null] :
  tmp = mCSetType {$ret = $tmp.ret;} EOF ;


  mCSetType returns [de.monticore.types.mccollectiontypes._ast.ASTMCSetType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mccollectiontypes._ast.ASTMCSetType _aNode = null;
_aNode=de.monticore.types.mccollectiontypes._ast.MCCollectionTypesNodeFactory.createASTMCSetType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  {next("Set")}?
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal <'
LT// End of 'ASTTerminal'

   tmp1=mCTypeArgument{addToIteratedAttributeIfNotNull(_aNode.getMCTypeArgumentList(), _localctx.tmp1.ret);}  
  
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCBasicTypeArgument'


mCBasicTypeArgument_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCBasicTypeArgument ret = null] :
  tmp = mCBasicTypeArgument {$ret = $tmp.ret;} EOF ;


  mCBasicTypeArgument returns [de.monticore.types.mccollectiontypes._ast.ASTMCBasicTypeArgument ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mccollectiontypes._ast.ASTMCBasicTypeArgument _aNode = null;
_aNode=de.monticore.types.mccollectiontypes._ast.MCCollectionTypesNodeFactory.createASTMCBasicTypeArgument();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCQualifiedType{_aNode.setMCQualifiedType(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCPrimitiveTypeArgument'


mCPrimitiveTypeArgument_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCPrimitiveTypeArgument ret = null] :
  tmp = mCPrimitiveTypeArgument {$ret = $tmp.ret;} EOF ;


  mCPrimitiveTypeArgument returns [de.monticore.types.mccollectiontypes._ast.ASTMCPrimitiveTypeArgument ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mccollectiontypes._ast.ASTMCPrimitiveTypeArgument _aNode = null;
_aNode=de.monticore.types.mccollectiontypes._ast.MCCollectionTypesNodeFactory.createASTMCPrimitiveTypeArgument();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCPrimitiveType{_aNode.setMCPrimitiveType(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCBasicGenericType'


mCBasicGenericType_eof returns [de.monticore.types.mcsimplegenerictypes._ast.ASTMCBasicGenericType ret = null] :
  tmp = mCBasicGenericType {$ret = $tmp.ret;} EOF ;


  mCBasicGenericType returns [de.monticore.types.mcsimplegenerictypes._ast.ASTMCBasicGenericType ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcsimplegenerictypes._ast.ASTMCBasicGenericType _aNode = null;
_aNode=de.monticore.types.mcsimplegenerictypes._ast.MCSimpleGenericTypesNodeFactory.createASTMCBasicGenericType();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getNameList(), convertName($tmp0));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getNameList(), convertName($tmp1));}

  ) 
  
  
)*
  
)
  
 // Start of 'ASTTerminal <'
LT// End of 'ASTTerminal'

  (
  
   tmp2=mCTypeArgument{addToIteratedAttributeIfNotNull(_aNode.getMCTypeArgumentList(), _localctx.tmp2.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp3=mCTypeArgument{addToIteratedAttributeIfNotNull(_aNode.getMCTypeArgumentList(), _localctx.tmp3.ret);}  
  
  
)*
  
)?
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd MCCustomTypeArgument'


mCCustomTypeArgument_eof returns [de.monticore.types.mcsimplegenerictypes._ast.ASTMCCustomTypeArgument ret = null] :
  tmp = mCCustomTypeArgument {$ret = $tmp.ret;} EOF ;


  mCCustomTypeArgument returns [de.monticore.types.mcsimplegenerictypes._ast.ASTMCCustomTypeArgument ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.types.mcsimplegenerictypes._ast.ASTMCCustomTypeArgument _aNode = null;
_aNode=de.monticore.types.mcsimplegenerictypes._ast.MCSimpleGenericTypesNodeFactory.createASTMCCustomTypeArgument();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCType{_aNode.setMCType(_localctx.tmp0.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDCompilationUnit'


cDCompilationUnit_eof returns [classdiagrams._ast.ASTCDCompilationUnit ret = null] :
  tmp = cDCompilationUnit {$ret = $tmp.ret;} EOF ;


  cDCompilationUnit returns [classdiagrams._ast.ASTCDCompilationUnit ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDCompilationUnit _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDCompilationUnit();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTTerminal package'
'package'// End of 'ASTTerminal'

  (
  
  (tmp0=Name{ addToIteratedAttributeIfNotNull(_aNode.getPackageList(), convertName($tmp0));}

  /* Automatically added keywords [null, true, false, import, boolean, byte, short, int, long, char, float, double, void, package, classdiagram, class, extends, interface, throws, abstract, final, static, private, protected, public, derived] */
   | 
  ('null'{_aNode.getPackageList().add("null");})
   | 
  ('true'{_aNode.getPackageList().add("true");})
   | 
  ('false'{_aNode.getPackageList().add("false");})
   | 
  ('import'{_aNode.getPackageList().add("import");})
   | 
  ('boolean'{_aNode.getPackageList().add("boolean");})
   | 
  ('byte'{_aNode.getPackageList().add("byte");})
   | 
  ('short'{_aNode.getPackageList().add("short");})
   | 
  ('int'{_aNode.getPackageList().add("int");})
   | 
  ('long'{_aNode.getPackageList().add("long");})
   | 
  ('char'{_aNode.getPackageList().add("char");})
   | 
  ('float'{_aNode.getPackageList().add("float");})
   | 
  ('double'{_aNode.getPackageList().add("double");})
   | 
  ('void'{_aNode.getPackageList().add("void");})
   | 
  ('package'{_aNode.getPackageList().add("package");})
   | 
  ('classdiagram'{_aNode.getPackageList().add("classdiagram");})
   | 
  ('class'{_aNode.getPackageList().add("class");})
   | 
  ('extends'{_aNode.getPackageList().add("extends");})
   | 
  ('interface'{_aNode.getPackageList().add("interface");})
   | 
  ('throws'{_aNode.getPackageList().add("throws");})
   | 
  ('abstract'{_aNode.getPackageList().add("abstract");})
   | 
  ('final'{_aNode.getPackageList().add("final");})
   | 
  ('static'{_aNode.getPackageList().add("static");})
   | 
  ('private'{_aNode.getPackageList().add("private");})
   | 
  ('protected'{_aNode.getPackageList().add("protected");})
   | 
  ('public'{_aNode.getPackageList().add("public");})
   | 
  ('derived'{_aNode.getPackageList().add("derived");})
  ) 
  
  (
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Name{ addToIteratedAttributeIfNotNull(_aNode.getPackageList(), convertName($tmp1));}

  /* Automatically added keywords [null, true, false, import, boolean, byte, short, int, long, char, float, double, void, package, classdiagram, class, extends, interface, throws, abstract, final, static, private, protected, public, derived] */
   | 
  ('null'{_aNode.getPackageList().add("null");})
   | 
  ('true'{_aNode.getPackageList().add("true");})
   | 
  ('false'{_aNode.getPackageList().add("false");})
   | 
  ('import'{_aNode.getPackageList().add("import");})
   | 
  ('boolean'{_aNode.getPackageList().add("boolean");})
   | 
  ('byte'{_aNode.getPackageList().add("byte");})
   | 
  ('short'{_aNode.getPackageList().add("short");})
   | 
  ('int'{_aNode.getPackageList().add("int");})
   | 
  ('long'{_aNode.getPackageList().add("long");})
   | 
  ('char'{_aNode.getPackageList().add("char");})
   | 
  ('float'{_aNode.getPackageList().add("float");})
   | 
  ('double'{_aNode.getPackageList().add("double");})
   | 
  ('void'{_aNode.getPackageList().add("void");})
   | 
  ('package'{_aNode.getPackageList().add("package");})
   | 
  ('classdiagram'{_aNode.getPackageList().add("classdiagram");})
   | 
  ('class'{_aNode.getPackageList().add("class");})
   | 
  ('extends'{_aNode.getPackageList().add("extends");})
   | 
  ('interface'{_aNode.getPackageList().add("interface");})
   | 
  ('throws'{_aNode.getPackageList().add("throws");})
   | 
  ('abstract'{_aNode.getPackageList().add("abstract");})
   | 
  ('final'{_aNode.getPackageList().add("final");})
   | 
  ('static'{_aNode.getPackageList().add("static");})
   | 
  ('private'{_aNode.getPackageList().add("private");})
   | 
  ('protected'{_aNode.getPackageList().add("protected");})
   | 
  ('public'{_aNode.getPackageList().add("public");})
   | 
  ('derived'{_aNode.getPackageList().add("derived");})
  ) 
  
  
)*
  
)
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  
)?
  (
  
   tmp2=mCImportStatement{addToIteratedAttributeIfNotNull(_aNode.getMCImportStatementList(), _localctx.tmp2.ret);}  
  
  
)*
   tmp3=cDDefinition{_aNode.setCDDefinition(_localctx.tmp3.ret);}  
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDDefinition'


cDDefinition_eof returns [classdiagrams._ast.ASTCDDefinition ret = null] :
  tmp = cDDefinition {$ret = $tmp.ret;} EOF ;


  cDDefinition returns [classdiagrams._ast.ASTCDDefinition ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDDefinition _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDDefinition();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  ( tmp0=modifier{_aNode.setModifier(_localctx.tmp0.ret);}) ? 
  
  
 // Start of 'ASTTerminal classdiagram'
'classdiagram'// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal {'
LCURLY// End of 'ASTTerminal'

  (
  
   tmp2=cDClass{addToIteratedAttributeIfNotNull(_aNode.getCDClassList(), _localctx.tmp2.ret);}  
  
  |
   tmp3=cDInterface{addToIteratedAttributeIfNotNull(_aNode.getCDInterfaceList(), _localctx.tmp3.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
RCURLY// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDClass'


cDClass_eof returns [classdiagrams._ast.ASTCDClass ret = null] :
  tmp = cDClass {$ret = $tmp.ret;} EOF ;


  cDClass returns [classdiagrams._ast.ASTCDClass ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDClass _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDClass();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  ( tmp0=modifier{_aNode.setModifier(_localctx.tmp0.ret);}) ? 
  
  
 // Start of 'ASTTerminal class'
'class'// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal extends'
'extends'// End of 'ASTTerminal'

   tmp2=mCObjectType{_aNode.setSuperclass(_localctx.tmp2.ret);}  
  
  
)?
  (
  
   tmp3=tImplements{_aNode.setTImplements(_localctx.tmp3.ret);}  
  
  (
  
   tmp4=mCObjectType{addToIteratedAttributeIfNotNull(_aNode.getInterfaceList(), _localctx.tmp4.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp5=mCObjectType{addToIteratedAttributeIfNotNull(_aNode.getInterfaceList(), _localctx.tmp5.ret);}  
  
  
)*
  
)
  
)?
  (
  
  
 // Start of 'ASTTerminal {'
LCURLY// End of 'ASTTerminal'

  (
  
   tmp6=cDAttribute{addToIteratedAttributeIfNotNull(_aNode.getCDAttributeList(), _localctx.tmp6.ret);}  
  
  |
   tmp7=cDConstructor{addToIteratedAttributeIfNotNull(_aNode.getCDConstructorList(), _localctx.tmp7.ret);}  
  
  |
   tmp8=cDMethod{addToIteratedAttributeIfNotNull(_aNode.getCDMethodList(), _localctx.tmp8.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
RCURLY// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd TImplements'


tImplements_eof returns [classdiagrams._ast.ASTTImplements ret = null] :
  tmp = tImplements {$ret = $tmp.ret;} EOF ;


  tImplements returns [classdiagrams._ast.ASTTImplements ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTTImplements _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTTImplements();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  {_input.LT(1).getText().equals("implements")}?
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDInterface'


cDInterface_eof returns [classdiagrams._ast.ASTCDInterface ret = null] :
  tmp = cDInterface {$ret = $tmp.ret;} EOF ;


  cDInterface returns [classdiagrams._ast.ASTCDInterface ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDInterface _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDInterface();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  ( tmp0=modifier{_aNode.setModifier(_localctx.tmp0.ret);}) ? 
  
  
 // Start of 'ASTTerminal interface'
'interface'// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  (
  
  
 // Start of 'ASTTerminal extends'
'extends'// End of 'ASTTerminal'

  (
  
   tmp2=mCObjectType{addToIteratedAttributeIfNotNull(_aNode.getInterfaceList(), _localctx.tmp2.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp3=mCObjectType{addToIteratedAttributeIfNotNull(_aNode.getInterfaceList(), _localctx.tmp3.ret);}  
  
  
)*
  
)
  
)?
  (
  
  
 // Start of 'ASTTerminal {'
LCURLY// End of 'ASTTerminal'

  (
  
   tmp4=cDAttribute{addToIteratedAttributeIfNotNull(_aNode.getCDAttributeList(), _localctx.tmp4.ret);}  
  
  |
   tmp5=cDMethod{addToIteratedAttributeIfNotNull(_aNode.getCDMethodList(), _localctx.tmp5.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
RCURLY// End of 'ASTTerminal'

  |
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDAttribute'


cDAttribute_eof returns [classdiagrams._ast.ASTCDAttribute ret = null] :
  tmp = cDAttribute {$ret = $tmp.ret;} EOF ;


  cDAttribute returns [classdiagrams._ast.ASTCDAttribute ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDAttribute _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDAttribute();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  ( tmp0=modifier{_aNode.setModifier(_localctx.tmp0.ret);}) ? 
  
   tmp1=mCType{_aNode.setMCType(_localctx.tmp1.ret);}  
  
  (tmp2=Name{_aNode.setName(convertName($tmp2));}

  ) 
  
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDConstructor'


cDConstructor_eof returns [classdiagrams._ast.ASTCDConstructor ret = null] :
  tmp = cDConstructor {$ret = $tmp.ret;} EOF ;


  cDConstructor returns [classdiagrams._ast.ASTCDConstructor ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDConstructor _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDConstructor();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=modifier{_aNode.setModifier(_localctx.tmp0.ret);}  
  
  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal ('
LPAREN// End of 'ASTTerminal'

  (
  
   tmp2=cDParameter{addToIteratedAttributeIfNotNull(_aNode.getCDParameterList(), _localctx.tmp2.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp3=cDParameter{addToIteratedAttributeIfNotNull(_aNode.getCDParameterList(), _localctx.tmp3.ret);}  
  
  
)*
  
)?
  
 // Start of 'ASTTerminal )'
RPAREN// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal throws'
'throws'// End of 'ASTTerminal'

  (
  
   tmp4=mCQualifiedName{addToIteratedAttributeIfNotNull(_aNode.getExceptionList(), _localctx.tmp4.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp5=mCQualifiedName{addToIteratedAttributeIfNotNull(_aNode.getExceptionList(), _localctx.tmp5.ret);}  
  
  
)*
  
)
  
)?
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDMethod'


cDMethod_eof returns [classdiagrams._ast.ASTCDMethod ret = null] :
  tmp = cDMethod {$ret = $tmp.ret;} EOF ;


  cDMethod returns [classdiagrams._ast.ASTCDMethod ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDMethod _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDMethod();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=modifier{_aNode.setModifier(_localctx.tmp0.ret);}  
  
   tmp1=mCReturnType{_aNode.setMCReturnType(_localctx.tmp1.ret);}  
  
  (tmp2=Name{_aNode.setName(convertName($tmp2));}

  ) 
  
  
 // Start of 'ASTTerminal ('
LPAREN// End of 'ASTTerminal'

  (
  
   tmp3=cDParameter{addToIteratedAttributeIfNotNull(_aNode.getCDParameterList(), _localctx.tmp3.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp4=cDParameter{addToIteratedAttributeIfNotNull(_aNode.getCDParameterList(), _localctx.tmp4.ret);}  
  
  
)*
  
)?
  
 // Start of 'ASTTerminal )'
RPAREN// End of 'ASTTerminal'

  (
  
  
 // Start of 'ASTTerminal throws'
'throws'// End of 'ASTTerminal'

  (
  
   tmp5=mCQualifiedName{addToIteratedAttributeIfNotNull(_aNode.getExceptionList(), _localctx.tmp5.ret);}  
  
  (
  
  
 // Start of 'ASTTerminal ,'
COMMA// End of 'ASTTerminal'

   tmp6=mCQualifiedName{addToIteratedAttributeIfNotNull(_aNode.getExceptionList(), _localctx.tmp6.ret);}  
  
  
)*
  
)
  
)?
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CDParameter'


cDParameter_eof returns [classdiagrams._ast.ASTCDParameter ret = null] :
  tmp = cDParameter {$ret = $tmp.ret;} EOF ;


  cDParameter returns [classdiagrams._ast.ASTCDParameter ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTCDParameter _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTCDParameter();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
   tmp0=mCType{_aNode.setMCType(_localctx.tmp0.ret);}  
  
  (
  
  
 // Start of 'ASTConstantGroup'
(POINTPOINTPOINT{
_aNode.setEllipsis(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Modifier'


modifier_eof returns [classdiagrams._ast.ASTModifier ret = null] :
  tmp = modifier {$ret = $tmp.ret;} EOF ;


  modifier returns [classdiagrams._ast.ASTModifier ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
classdiagrams._ast.ASTModifier _aNode = null;
_aNode=classdiagrams._ast.ClassDiagramsNodeFactory.createASTModifier();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
('abstract'{
_aNode.setAbstract(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
('final'{
_aNode.setFinal(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
('static'{
_aNode.setStatic(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
('private'{
_aNode.setPrivate(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setPrivate(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
('protected'{
_aNode.setProtected(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
(HASH{
_aNode.setProtected(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
('public'{
_aNode.setPublic(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
(PLUS{
_aNode.setPublic(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
('derived'{
_aNode.setDerived(true);
})// End of 'ASTConstantGroup'

  |
  
 // Start of 'ASTConstantGroup'
(SLASH{
_aNode.setDerived(true);
})// End of 'ASTConstantGroup'

  
)*
  ;
  // End of 'ASTClassProd'


  
 // Start of 'Literal'


literal_eof returns [de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ret = null] :
  tmp = literal {$ret = $tmp.ret;} EOF ;


  literal
   returns [de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ret]
  : 
  
  tmp0=nullLiteral
{$ret=$tmp0.ret;}
  |
  tmp1=booleanLiteral
{$ret=$tmp1.ret;}
  |
  tmp2=charLiteral
{$ret=$tmp2.ret;}
  |
  tmp3=stringLiteral
{$ret=$tmp3.ret;}
  |
  tmp4=numericLiteral
{$ret=$tmp4.ret;}
  ;
  
 // Start of 'SignedLiteral'


signedLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ret = null] :
  tmp = signedLiteral {$ret = $tmp.ret;} EOF ;


  signedLiteral
   returns [de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ret]
  : 
  
  tmp0=nullLiteral
{$ret=$tmp0.ret;}
  |
  tmp1=booleanLiteral
{$ret=$tmp1.ret;}
  |
  tmp2=charLiteral
{$ret=$tmp2.ret;}
  |
  tmp3=stringLiteral
{$ret=$tmp3.ret;}
  |
  tmp5=signedNumericLiteral
{$ret=$tmp5.ret;}
  ;
  
 // Start of 'NumericLiteral'


numericLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ret = null] :
  tmp = numericLiteral {$ret = $tmp.ret;} EOF ;


  numericLiteral
   returns [de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ret]
  : 
  
  tmp6=natLiteral
{$ret=$tmp6.ret;}
  |
  tmp7=basicLongLiteral
{$ret=$tmp7.ret;}
  |
  tmp8=basicFloatLiteral
{$ret=$tmp8.ret;}
  |
  tmp9=basicDoubleLiteral
{$ret=$tmp9.ret;}
  ;
  
 // Start of 'SignedNumericLiteral'


signedNumericLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ret = null] :
  tmp = signedNumericLiteral {$ret = $tmp.ret;} EOF ;


  signedNumericLiteral
   returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ret]
  : 
  
  tmp10=signedNatLiteral
{$ret=$tmp10.ret;}
  |
  tmp11=signedBasicLongLiteral
{$ret=$tmp11.ret;}
  |
  tmp12=signedBasicFloatLiteral
{$ret=$tmp12.ret;}
  |
  tmp13=signedBasicDoubleLiteral
{$ret=$tmp13.ret;}
  ;
  
 // Start of 'Type'


type_eof returns [de.monticore.types.typesymbols._ast.ASTType ret = null] :
  tmp = type {$ret = $tmp.ret;} EOF ;


  type
   returns [de.monticore.types.typesymbols._ast.ASTType ret]
  : 
  ;
  
 // Start of 'TypeVar'


typeVar_eof returns [de.monticore.types.typesymbols._ast.ASTTypeVar ret = null] :
  tmp = typeVar {$ret = $tmp.ret;} EOF ;


  typeVar
   returns [de.monticore.types.typesymbols._ast.ASTTypeVar ret]
  : 
  ;
  
 // Start of 'Field'


field_eof returns [de.monticore.types.typesymbols._ast.ASTField ret = null] :
  tmp = field {$ret = $tmp.ret;} EOF ;


  field
   returns [de.monticore.types.typesymbols._ast.ASTField ret]
  : 
  ;
  
 // Start of 'Method'


method_eof returns [de.monticore.types.typesymbols._ast.ASTMethod ret = null] :
  tmp = method {$ret = $tmp.ret;} EOF ;


  method
   returns [de.monticore.types.typesymbols._ast.ASTMethod ret]
  : 
  ;
  
 // Start of 'MCType'


mCType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCType ret = null] :
  tmp = mCType {$ret = $tmp.ret;} EOF ;


  mCType
   returns [de.monticore.types.mcbasictypes._ast.ASTMCType ret]
  : 
  
  tmp14=mCPrimitiveType
{$ret=$tmp14.ret;}
  |
  tmp15=mCObjectType
{$ret=$tmp15.ret;}
  ;
  
 // Start of 'MCObjectType'


mCObjectType_eof returns [de.monticore.types.mcbasictypes._ast.ASTMCObjectType ret = null] :
  tmp = mCObjectType {$ret = $tmp.ret;} EOF ;


  mCObjectType
   returns [de.monticore.types.mcbasictypes._ast.ASTMCObjectType ret]
  : 
  
  tmp16=mCGenericType
{$ret=$tmp16.ret;}
  |
  tmp17=mCQualifiedType
{$ret=$tmp17.ret;}
  ;
  
 // Start of 'MCGenericType'


mCGenericType_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCGenericType ret = null] :
  tmp = mCGenericType {$ret = $tmp.ret;} EOF ;


  mCGenericType
   returns [de.monticore.types.mccollectiontypes._ast.ASTMCGenericType ret]
  : 
  
  tmp18=mCListType
{$ret=$tmp18.ret;}
  |
  tmp19=mCOptionalType
{$ret=$tmp19.ret;}
  |
  tmp20=mCMapType
{$ret=$tmp20.ret;}
  |
  tmp21=mCSetType
{$ret=$tmp21.ret;}
  |
  tmp22=mCBasicGenericType
{$ret=$tmp22.ret;}
  ;
  
 // Start of 'MCTypeArgument'


mCTypeArgument_eof returns [de.monticore.types.mccollectiontypes._ast.ASTMCTypeArgument ret = null] :
  tmp = mCTypeArgument {$ret = $tmp.ret;} EOF ;


  mCTypeArgument
   returns [de.monticore.types.mccollectiontypes._ast.ASTMCTypeArgument ret]
  : 
  
  tmp23=mCBasicTypeArgument
{$ret=$tmp23.ret;}
  |
  tmp24=mCPrimitiveTypeArgument
{$ret=$tmp24.ret;}
  |
  tmp25=mCCustomTypeArgument
{$ret=$tmp25.ret;}
  ;
  
 // Start of 'CDType'


cDType_eof returns [classdiagrams._ast.ASTCDType ret = null] :
  tmp = cDType {$ret = $tmp.ret;} EOF ;


  cDType
   returns [classdiagrams._ast.ASTCDType ret]
  : 
  
  tmp26=cDClass
{$ret=$tmp26.ret;}
  |
  tmp27=cDInterface
{$ret=$tmp27.ret;}
  ;
  
 // Start of 'CDField'


cDField_eof returns [classdiagrams._ast.ASTCDField ret = null] :
  tmp = cDField {$ret = $tmp.ret;} EOF ;


  cDField
   returns [classdiagrams._ast.ASTCDField ret]
  : 
  
  tmp28=cDAttribute
{$ret=$tmp28.ret;}
  |
  tmp29=cDParameter
{$ret=$tmp29.ret;}
  ;
  
 // Start of 'CDMethOrConstr'


cDMethOrConstr_eof returns [classdiagrams._ast.ASTCDMethOrConstr ret = null] :
  tmp = cDMethOrConstr {$ret = $tmp.ret;} EOF ;


  cDMethOrConstr
   returns [classdiagrams._ast.ASTCDMethOrConstr ret]
  : 
  
  tmp30=cDConstructor
{$ret=$tmp30.ret;}
  |
  tmp31=cDMethod
{$ret=$tmp31.ret;}
  ;
 
  HASH : '#';
  LPAREN : '(';
  RPAREN : ')';
  STAR : '*';
  PLUS : '+';
  COMMA : ',';
  MINUS : '-';
  POINT : '.';
  POINTPOINTPOINT : '...';
  SLASH : '/';
  SEMI : ';';
  LCURLY : '{';
  LT : '<';
  RCURLY : '}';
  GT : '>';
 
  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
  {_input.LA(2) != '/'}?
  '*' 
  |
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Digits'
Digits 
  
:
  
  (
   Digit 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Digit'
fragment Digit 
  
:
  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Char'
Char 
  
:
  
  '\'' 
  (
  
   SingleCharacter 
  |
   EscapeSequence 
  )

  '\'' 
  {setText(getText().substring(1,getText().length() - 1));

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SingleCharacter'
fragment SingleCharacter 
  
:
  
  ~(
  
  '\'' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd String'
String 
  
:
  
  '"' 
  (
  
   StringCharacters 
  )
?
  '"' 
  {setText(getText().substring(1,getText().length() - 1));

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd StringCharacters'
fragment StringCharacters 
  
:
  
  (
  
   StringCharacter 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd StringCharacter'
fragment StringCharacter 
  
:
  
  ~(
  
  '"' 
  |
  '\\' 
  )

  |
   EscapeSequence 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd EscapeSequence'
fragment EscapeSequence 
  
:
  
  '\\' 
  (
  
  'b' 
  |
  't' 
  |
  'n' 
  |
  'f' 
  |
  'r' 
  |
  '"' 
  |
  '\'' 
  |
  '\\' 
  )

  |
   OctalEscape 
  |
   UnicodeEscape 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalEscape'
fragment OctalEscape 
  
:
  
  '\\' 
   OctalDigit 
  |
  '\\' 
   OctalDigit 
   OctalDigit 
  |
  '\\' 
   ZeroToThree 
   OctalDigit 
   OctalDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnicodeEscape'
fragment UnicodeEscape 
  
:
  
  '\\' 
  'u' 
   HexDigit 
   HexDigit 
   HexDigit 
   HexDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ZeroToThree'
fragment ZeroToThree 
  
:
  
  '0'..'3'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexDigit'
fragment HexDigit 
  
:
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalDigit'
fragment OctalDigit 
  
:
  
  '0'..'7'  
  ;// End of 'ASTLexProd'


