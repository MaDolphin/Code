/* generated from model ClassDiagrams */
/* generated by template core.Interface*/

/* (c) https://github.com/MontiCore/monticore */
package classdiagrams._symboltable;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;


 public  interface IClassDiagramsGlobalScope extends classdiagrams._symboltable.IClassDiagramsScope,de.monticore.symboltable.IGlobalScope {



  /* generated by template core.Method*/
 abstract  public  ClassDiagramsLanguage getClassDiagramsLanguage () ;
  /* generated by template core.Method*/
 abstract  public  void cache (String calculatedModelName) ;
  default /* generated by template core.Method*/
 public  boolean checkIfContinueAsSubScope (String symbolName)  {
      return false;
}

  /* generated by template core.Method*/
 abstract  public  boolean continueWithModelLoader (String calculatedModelName,ClassDiagramsModelLoader modelLoader) ;
  default /* generated by template core.Method*/
 public  IClassDiagramsGlobalScope getRealThis ()  {
      return this;
}

  default /* generated by template core.Method*/
 public  List<classdiagrams._symboltable.CDDefinitionSymbol> resolveCDDefinitionMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<classdiagrams._symboltable.CDDefinitionSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<classdiagrams._symboltable.CDDefinitionSymbol> resolvedSymbol = resolveCDDefinitionDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForCDDefinition(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveCDDefinitionDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isCDDefinitionSymbolsAlreadyResolved()){
    setCDDefinitionSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedCDDefinition(foundSymbols, name, modifier, predicate));
  }
  setCDDefinitionSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<classdiagrams._symboltable.CDDefinitionSymbol> resolveAdaptedCDDefinition (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<classdiagrams._symboltable.CDDefinitionSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForCDDefinition (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  ClassDiagramsModelLoader modelLoader = getClassDiagramsLanguage().getModelLoader();
  Set<String> calculatedModelNames = getClassDiagramsLanguage().calculateModelNamesForCDDefinition(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        ClassDiagramsGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeSymbol> resolveTypeMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.TypeSymbol> resolvedSymbol = resolveTypeDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForType(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveTypeDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isTypeSymbolsAlreadyResolved()){
    setTypeSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedType(foundSymbols, name, modifier, predicate));
  }
  setTypeSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeSymbol> resolveAdaptedType (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForType (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  ClassDiagramsModelLoader modelLoader = getClassDiagramsLanguage().getModelLoader();
  Set<String> calculatedModelNames = getClassDiagramsLanguage().calculateModelNamesForType(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        ClassDiagramsGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> resolveTypeVarMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> resolvedSymbol = resolveTypeVarDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForTypeVar(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveTypeVarDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isTypeVarSymbolsAlreadyResolved()){
    setTypeVarSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedTypeVar(foundSymbols, name, modifier, predicate));
  }
  setTypeVarSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> resolveAdaptedTypeVar (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.TypeVarSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForTypeVar (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  ClassDiagramsModelLoader modelLoader = getClassDiagramsLanguage().getModelLoader();
  Set<String> calculatedModelNames = getClassDiagramsLanguage().calculateModelNamesForTypeVar(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        ClassDiagramsGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.FieldSymbol> resolveFieldMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.FieldSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.FieldSymbol> resolvedSymbol = resolveFieldDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForField(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveFieldDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isFieldSymbolsAlreadyResolved()){
    setFieldSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedField(foundSymbols, name, modifier, predicate));
  }
  setFieldSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.FieldSymbol> resolveAdaptedField (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.FieldSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForField (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  ClassDiagramsModelLoader modelLoader = getClassDiagramsLanguage().getModelLoader();
  Set<String> calculatedModelNames = getClassDiagramsLanguage().calculateModelNamesForField(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        ClassDiagramsGlobalScope.class.getSimpleName());
    }
  }
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.MethodSymbol> resolveMethodMany (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.MethodSymbol> predicate)  {
      /* generated by template _symboltable.iglobalscope.ResolveMany*/

  // First, try to resolve the symbol in the current scope and its sub scopes.
  List<de.monticore.types.typesymbols._symboltable.MethodSymbol> resolvedSymbol = resolveMethodDownMany(foundSymbols, name,  modifier, predicate);

  if (!resolvedSymbol.isEmpty()) {
    return resolvedSymbol;
  }

  // Symbol not found: try to load corresponding model and build its symbol table
  loadModelsForMethod(name);

  // Maybe the symbol now exists in this scope (or its sub scopes). So, resolve down, again.
  resolvedSymbol = resolveMethodDownMany(false, name, modifier, predicate);
  foundSymbols = foundSymbols  | resolvedSymbol.size() > 0;
  if (!foundSymbols && !isMethodSymbolsAlreadyResolved()){
    setMethodSymbolsAlreadyResolved(true);
    resolvedSymbol.addAll(resolveAdaptedMethod(foundSymbols, name, modifier, predicate));
  }
  setMethodSymbolsAlreadyResolved(false);
  return resolvedSymbol;
}

  default /* generated by template core.Method*/
 public  List<de.monticore.types.typesymbols._symboltable.MethodSymbol> resolveAdaptedMethod (boolean foundSymbols,String name,de.monticore.symboltable.modifiers.AccessModifier modifier,java.util.function.Predicate<de.monticore.types.typesymbols._symboltable.MethodSymbol> predicate)  {
      return com.google.common.collect.Lists.newArrayList();
}

  default /* generated by template core.Method*/
 public  void loadModelsForMethod (String name)  {
      /* generated by template _symboltable.iglobalscope.LoadModelsFor*/

  ClassDiagramsModelLoader modelLoader = getClassDiagramsLanguage().getModelLoader();
  Set<String> calculatedModelNames = getClassDiagramsLanguage().calculateModelNamesForMethod(name);

  for (String calculatedModelName : calculatedModelNames) {
    if (continueWithModelLoader(calculatedModelName, modelLoader)) {
      modelLoader.loadModelsIntoScope(calculatedModelName, getModelPath(), getRealThis());
      cache(calculatedModelNames.iterator().next());
    } else {
      Log.debug("Already tried to load model for '" + name + "'. If model exists, continue with cached version.",
        ClassDiagramsGlobalScope.class.getSimpleName());
    }
  }
}

}
