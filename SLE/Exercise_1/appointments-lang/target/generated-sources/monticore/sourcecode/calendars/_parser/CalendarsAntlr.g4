/* generated by template parser.Parser*/


/* generated by template parser.ParserHeader*/
grammar CalendarsAntlr;
@parser::header {
package calendars._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package calendars._parser;
}
options {
superClass=MCParser;
}

@parser::members

{

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for Digits
private String convertDigits(Token t)  {
    return t.getText();
}

  // convert function for Digit
private String convertDigit(Token t)  {
    return t.getText();
}

  // convert function for Char
private String convertChar(Token t)  {
    return t.getText();
}

  // convert function for SingleCharacter
private String convertSingleCharacter(Token t)  {
    return t.getText();
}

  // convert function for String
private String convertString(Token t)  {
    return t.getText();
}

  // convert function for StringCharacters
private String convertStringCharacters(Token t)  {
    return t.getText();
}

  // convert function for StringCharacter
private String convertStringCharacter(Token t)  {
    return t.getText();
}

  // convert function for EscapeSequence
private String convertEscapeSequence(Token t)  {
    return t.getText();
}

  // convert function for OctalEscape
private String convertOctalEscape(Token t)  {
    return t.getText();
}

  // convert function for UnicodeEscape
private String convertUnicodeEscape(Token t)  {
    return t.getText();
}

  // convert function for ZeroToThree
private String convertZeroToThree(Token t)  {
    return t.getText();
}

  // convert function for HexDigit
private String convertHexDigit(Token t)  {
    return t.getText();
}

  // convert function for OctalDigit
private String convertOctalDigit(Token t)  {
    return t.getText();
}

}

/* generated by template parser.LexerMember*/


@lexer::members {



private CalendarsAntlrParser _monticore_parser;

protected CalendarsAntlrParser getCompiler() {
   return _monticore_parser;
}

public void setMCParser(CalendarsAntlrParser in) {
  this._monticore_parser = in;
}

protected void storeComment(){
  if (getCompiler() != null) {
    de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
    de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
    _comment.set_SourcePositionStart(startPos);
    _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
    getCompiler().addComment(_comment);
  }
}
}


  
 // Start of 'ASTClassProd NullLiteral'


nullLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ret = null] :
  tmp = nullLiteral {$ret = $tmp.ret;} EOF ;


  nullLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTNullLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTNullLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTNullLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal null'
'null'// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BooleanLiteral'


booleanLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ret = null] :
  tmp = booleanLiteral {$ret = $tmp.ret;} EOF ;


  booleanLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBooleanLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBooleanLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTConstantGroup'
('true'{
_aNode.setSource(de.monticore.literals.mccommonliterals._ast.ASTConstantsMCCommonLiterals.TRUE);
}|
'false'{
_aNode.setSource(de.monticore.literals.mccommonliterals._ast.ASTConstantsMCCommonLiterals.FALSE);
})// End of 'ASTConstantGroup'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd CharLiteral'


charLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ret = null] :
  tmp = charLiteral {$ret = $tmp.ret;} EOF ;


  charLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTCharLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTCharLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTCharLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Char{_aNode.setSource(convertChar($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd StringLiteral'


stringLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ret = null] :
  tmp = stringLiteral {$ret = $tmp.ret;} EOF ;


  stringLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTStringLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTStringLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTStringLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=String{_aNode.setSource(convertString($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd NatLiteral'


natLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ret = null] :
  tmp = natLiteral {$ret = $tmp.ret;} EOF ;


  natLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTNatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTNatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTNatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedNatLiteral'


signedNatLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ret = null] :
  tmp = signedNatLiteral {$ret = $tmp.ret;} EOF ;


  signedNatLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedNatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedNatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BasicLongLiteral'


basicLongLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ret = null] :
  tmp = basicLongLiteral {$ret = $tmp.ret;} EOF ;


  basicLongLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBasicLongLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBasicLongLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  {is("l","L")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedBasicLongLiteral'


signedBasicLongLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ret = null] :
  tmp = signedBasicLongLiteral {$ret = $tmp.ret;} EOF ;


  signedBasicLongLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedBasicLongLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedBasicLongLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setDigits(convertDigits($tmp0));}

  ) 
  
  (tmp1=Name{_aNode.setName(convertName($tmp1));}

  ) 
  
  {is("l","L")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BasicFloatLiteral'


basicFloatLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ret = null] :
  tmp = basicFloatLiteral {$ret = $tmp.ret;} EOF ;


  basicFloatLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBasicFloatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBasicFloatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  (tmp2=Name{_aNode.setName(convertName($tmp2));}

  ) 
  
  {is("f","F")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedBasicFloatLiteral'


signedBasicFloatLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ret = null] :
  tmp = signedBasicFloatLiteral {$ret = $tmp.ret;} EOF ;


  signedBasicFloatLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedBasicFloatLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedBasicFloatLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  (tmp2=Name{_aNode.setName(convertName($tmp2));}

  ) 
  
  {is("f","F")}?
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd BasicDoubleLiteral'


basicDoubleLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ret = null] :
  tmp = basicDoubleLiteral {$ret = $tmp.ret;} EOF ;


  basicDoubleLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTBasicDoubleLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTBasicDoubleLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd SignedBasicDoubleLiteral'


signedBasicDoubleLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ret = null] :
  tmp = signedBasicDoubleLiteral {$ret = $tmp.ret;} EOF ;


  signedBasicDoubleLiteral returns [de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
de.monticore.literals.mccommonliterals._ast.ASTSignedBasicDoubleLiteral _aNode = null;
_aNode=de.monticore.literals.mccommonliterals._ast.MCCommonLiteralsNodeFactory.createASTSignedBasicDoubleLiteral();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (
  
  
 // Start of 'ASTConstantGroup'
(MINUS{
_aNode.setNegative(true);
})// End of 'ASTConstantGroup'

  
)?
  (tmp0=Digits{_aNode.setPre(convertDigits($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal .'
POINT// End of 'ASTTerminal'

  (tmp1=Digits{_aNode.setPost(convertDigits($tmp1));}

  ) 
  
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Calendars'


calendars_eof returns [calendars._ast.ASTCalendars ret = null] :
  tmp = calendars {$ret = $tmp.ret;} EOF ;


  calendars returns [calendars._ast.ASTCalendars ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
calendars._ast.ASTCalendars _aNode = null;
_aNode=calendars._ast.CalendarsNodeFactory.createASTCalendars();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal `s calendar:'
'`s calendar:'// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'


  
 // Start of 'Literal'


literal_eof returns [de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ret = null] :
  tmp = literal {$ret = $tmp.ret;} EOF ;


  literal
   returns [de.monticore.literals.mcliteralsbasis._ast.ASTLiteral ret]
  : 
  
  tmp1=nullLiteral
{$ret=$tmp1.ret;}
  |
  tmp2=booleanLiteral
{$ret=$tmp2.ret;}
  |
  tmp3=charLiteral
{$ret=$tmp3.ret;}
  |
  tmp4=stringLiteral
{$ret=$tmp4.ret;}
  |
  tmp5=numericLiteral
{$ret=$tmp5.ret;}
  ;
  
 // Start of 'SignedLiteral'


signedLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ret = null] :
  tmp = signedLiteral {$ret = $tmp.ret;} EOF ;


  signedLiteral
   returns [de.monticore.literals.mccommonliterals._ast.ASTSignedLiteral ret]
  : 
  
  tmp1=nullLiteral
{$ret=$tmp1.ret;}
  |
  tmp2=booleanLiteral
{$ret=$tmp2.ret;}
  |
  tmp3=charLiteral
{$ret=$tmp3.ret;}
  |
  tmp4=stringLiteral
{$ret=$tmp4.ret;}
  |
  tmp6=signedNumericLiteral
{$ret=$tmp6.ret;}
  ;
  
 // Start of 'NumericLiteral'


numericLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ret = null] :
  tmp = numericLiteral {$ret = $tmp.ret;} EOF ;


  numericLiteral
   returns [de.monticore.literals.mccommonliterals._ast.ASTNumericLiteral ret]
  : 
  
  tmp7=natLiteral
{$ret=$tmp7.ret;}
  |
  tmp8=basicLongLiteral
{$ret=$tmp8.ret;}
  |
  tmp9=basicFloatLiteral
{$ret=$tmp9.ret;}
  |
  tmp10=basicDoubleLiteral
{$ret=$tmp10.ret;}
  ;
  
 // Start of 'SignedNumericLiteral'


signedNumericLiteral_eof returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ret = null] :
  tmp = signedNumericLiteral {$ret = $tmp.ret;} EOF ;


  signedNumericLiteral
   returns [de.monticore.literals.mccommonliterals._ast.ASTSignedNumericLiteral ret]
  : 
  
  tmp11=signedNatLiteral
{$ret=$tmp11.ret;}
  |
  tmp12=signedBasicLongLiteral
{$ret=$tmp12.ret;}
  |
  tmp13=signedBasicFloatLiteral
{$ret=$tmp13.ret;}
  |
  tmp14=signedBasicDoubleLiteral
{$ret=$tmp14.ret;}
  ;
  
 // Start of 'Appointments'


appointments_eof returns [calendars._ast.ASTAppointments ret = null] :
  tmp = appointments {$ret = $tmp.ret;} EOF ;


  appointments
   returns [calendars._ast.ASTAppointments ret]
  : 
  ;
 
  MINUS : '-';
  POINT : '.';
 
  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
  {_input.LA(2) != '/'}?
  '*' 
  |
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Digits'
Digits 
  
:
  
  (
   Digit 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Digit'
fragment Digit 
  
:
  
  '0'..'9'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd Char'
Char 
  
:
  
  '\'' 
  (
  
   SingleCharacter 
  |
   EscapeSequence 
  )

  '\'' 
  {setText(getText().substring(1,getText().length() - 1));

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SingleCharacter'
fragment SingleCharacter 
  
:
  
  ~(
  
  '\'' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd String'
String 
  
:
  
  '"' 
  (
  
   StringCharacters 
  )
?
  '"' 
  {setText(getText().substring(1,getText().length() - 1));

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd StringCharacters'
fragment StringCharacters 
  
:
  
  (
  
   StringCharacter 
  )
+
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd StringCharacter'
fragment StringCharacter 
  
:
  
  ~(
  
  '"' 
  |
  '\\' 
  )

  |
   EscapeSequence 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd EscapeSequence'
fragment EscapeSequence 
  
:
  
  '\\' 
  (
  
  'b' 
  |
  't' 
  |
  'n' 
  |
  'f' 
  |
  'r' 
  |
  '"' 
  |
  '\'' 
  |
  '\\' 
  )

  |
   OctalEscape 
  |
   UnicodeEscape 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalEscape'
fragment OctalEscape 
  
:
  
  '\\' 
   OctalDigit 
  |
  '\\' 
   OctalDigit 
   OctalDigit 
  |
  '\\' 
   ZeroToThree 
   OctalDigit 
   OctalDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd UnicodeEscape'
fragment UnicodeEscape 
  
:
  
  '\\' 
  'u' 
   HexDigit 
   HexDigit 
   HexDigit 
   HexDigit 
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ZeroToThree'
fragment ZeroToThree 
  
:
  
  '0'..'3'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd HexDigit'
fragment HexDigit 
  
:
  
  '0'..'9'  
  |
  'a'..'f'  
  |
  'A'..'F'  
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd OctalDigit'
fragment OctalDigit 
  
:
  
  '0'..'7'  
  ;// End of 'ASTLexProd'


