/* generated by template parser.Parser*/


/* generated by template parser.ParserHeader*/
grammar AutomataAntlr;
@parser::header {
package automata._parser;
import de.monticore.antlr4.MCParser;
}
@lexer::header {
package automata._parser;
}
options {
superClass=MCParser;
}

@parser::members

{

  // convert function for Name
private String convertName(Token t)  {
    return t.getText();
}

  // convert function for NEWLINE
private String convertNEWLINE(Token t)  {
    return t.getText();
}

  // convert function for WS
private String convertWS(Token t)  {
    return t.getText();
}

  // convert function for SL_COMMENT
private String convertSL_COMMENT(Token t)  {
    return t.getText();
}

  // convert function for ML_COMMENT
private String convertML_COMMENT(Token t)  {
    return t.getText();
}

}

/* generated by template parser.LexerMember*/


@lexer::members {



private AutomataAntlrParser _monticore_parser;

protected AutomataAntlrParser getCompiler() {
   return _monticore_parser;
}

public void setMCParser(AutomataAntlrParser in) {
  this._monticore_parser = in;
}

protected void storeComment(){
  if (getCompiler() != null) {
    de.monticore.ast.Comment _comment = new de.monticore.ast.Comment(getText());
    de.se_rwth.commons.SourcePosition startPos = new de.se_rwth.commons.SourcePosition(_tokenStartLine, _tokenStartCharPositionInLine);
    _comment.set_SourcePositionStart(startPos);
    _comment.set_SourcePositionEnd(getCompiler().computeEndPosition(startPos, getText()));
    getCompiler().addComment(_comment);
  }
}
}


  
 // Start of 'ASTClassProd Automaton'


automaton_eof returns [automata._ast.ASTAutomaton ret = null] :
  tmp = automaton {$ret = $tmp.ret;} EOF ;


  automaton returns [automata._ast.ASTAutomaton ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
automata._ast.ASTAutomaton _aNode = null;
_aNode=automata._ast.AutomataNodeFactory.createASTAutomaton();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal aut'
'aut'// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal {'
LCURLY// End of 'ASTTerminal'

  (
  
   tmp1=state{addToIteratedAttributeIfNotNull(_aNode.getStateList(), _localctx.tmp1.ret);}  
  
  |
   tmp2=transition{addToIteratedAttributeIfNotNull(_aNode.getTransitionList(), _localctx.tmp2.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
RCURLY// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd State'


state_eof returns [automata._ast.ASTState ret = null] :
  tmp = state {$ret = $tmp.ret;} EOF ;


  state returns [automata._ast.ASTState ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
automata._ast.ASTState _aNode = null;
_aNode=automata._ast.AutomataNodeFactory.createASTState();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  
 // Start of 'ASTTerminal state'
'state'// End of 'ASTTerminal'

  (tmp0=Name{_aNode.setName(convertName($tmp0));}

  ) 
  
  (
  
  (
  
  
 // Start of 'ASTTerminal <<'
LTLT// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
('initial'{
_aNode.setInitial(true);
})// End of 'ASTConstantGroup'

  
 // Start of 'ASTTerminal >>'
GTGT// End of 'ASTTerminal'

  
)
  |
  (
  
  
 // Start of 'ASTTerminal <<'
LTLT// End of 'ASTTerminal'

  
 // Start of 'ASTConstantGroup'
('final'{
_aNode.setFinal(true);
})// End of 'ASTConstantGroup'

  
 // Start of 'ASTTerminal >>'
GTGT// End of 'ASTTerminal'

  
)
  
)*
  (
  
  (
  
  
 // Start of 'ASTTerminal {'
LCURLY// End of 'ASTTerminal'

  (
  
   tmp1=state{addToIteratedAttributeIfNotNull(_aNode.getStateList(), _localctx.tmp1.ret);}  
  
  
)*
  
 // Start of 'ASTTerminal }'
RCURLY// End of 'ASTTerminal'

  
)
  |
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  
)
  ;
  // End of 'ASTClassProd'

  
 // Start of 'ASTClassProd Transition'


transition_eof returns [automata._ast.ASTTransition ret = null] :
  tmp = transition {$ret = $tmp.ret;} EOF ;


  transition returns [automata._ast.ASTTransition ret = null]
@init{// ret is normally returned, a is used to be compatible with rule using the return construct
automata._ast.ASTTransition _aNode = null;
_aNode=automata._ast.AutomataNodeFactory.createASTTransition();
$ret=_aNode;
_aNode.set_SourcePositionStart( computeStartPosition(_input.LT(1)));
setActiveASTNode(_aNode);
}
@after{_aNode.set_SourcePositionEnd(computeEndPosition(_input.LT(-1)));}
  
 : 
  
  (tmp0=Name{_aNode.setFrom(convertName($tmp0));}

  ) 
  
  
 // Start of 'ASTTerminal -'
MINUS// End of 'ASTTerminal'

  (tmp1=Name{_aNode.setInput(convertName($tmp1));}

  ) 
  
  
 // Start of 'ASTTerminal >'
GT// End of 'ASTTerminal'

  (tmp2=Name{_aNode.setTo(convertName($tmp2));}

  ) 
  
  
 // Start of 'ASTTerminal ;'
SEMI// End of 'ASTTerminal'

  ;
  // End of 'ASTClassProd'


 
  LTLT : '<<';
  GTGT : '>>';
  LCURLY : '{';
  SEMI : ';';
  RCURLY : '}';
  MINUS : '-';
  GT : '>';
 
  
 // Start of 'ASTLexProd Name'
Name 
  
:
  
  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '$' 
  )

  (
  
  'a'..'z'  
  |
  'A'..'Z'  
  |
  '_' 
  |
  '0'..'9'  
  |
  '$' 
  )
*
  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd NEWLINE'
fragment NEWLINE 
  
:
  
  (
  
  '\r' 
  '\n' 
  |
  '\r' 
  |
  '\n' 
  )

  ;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd WS'
WS 
  
:
  
  (
  
  ' ' 
  |
  '\t' 
  |
  '\r' 
  |
  '\n' 
  )

  {_channel=HIDDEN;

};// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd SL_COMMENT'
SL_COMMENT 
  
:
  
  '//' 
  (
  
  ~(
  
  '\n' 
  |
  '\r' 
  )

  )
*
  {storeComment();

}->skip
;// End of 'ASTLexProd'

  
 // Start of 'ASTLexProd ML_COMMENT'
ML_COMMENT 
  
:
  
  '/*' 
  (
  
  {_input.LA(2) != '/'}?
  '*' 
  |
   NEWLINE 
  |
  ~(
  
  '*' 
  |
  '\n' 
  |
  '\r' 
  )

  )
*
  '*/' 
  {storeComment();

}->skip
;// End of 'ASTLexProd'


