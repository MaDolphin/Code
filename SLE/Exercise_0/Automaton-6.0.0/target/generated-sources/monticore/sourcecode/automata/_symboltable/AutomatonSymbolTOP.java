/* generated from model Automata */
/* generated by template core.Class*/

/* (c) https://github.com/MontiCore/monticore */
package automata._symboltable;

/* generated by template core.Imports*/

import java.util.*;
import java.util.function.*;
import java.util.stream.Stream;
import de.se_rwth.commons.logging.Log;
import de.monticore.ast.ASTNode;
import de.monticore.ast.Comment;
import de.se_rwth.commons.SourcePosition;
import de.monticore.symboltable.*;
import de.monticore.ast.ASTCNode;


 abstract  public  class AutomatonSymbolTOP  implements automata._symboltable.ICommonAutomataSymbol,de.monticore.symboltable.IScopeSpanningSymbol {

    /* generated by template core.Attribute*/
 protected  String name ;

    /* generated by template core.Attribute*/
 protected  automata._symboltable.IAutomataScope enclosingScope ;

    /* generated by template core.Attribute*/
 protected  Optional<automata._ast.ASTAutomaton> astNode = Optional.empty();

    /* generated by template core.Attribute*/
 protected  de.monticore.symboltable.modifiers.AccessModifier accessModifier = de.monticore.symboltable.modifiers.AccessModifier.ALL_INCLUSION;

    /* generated by template core.Attribute*/
 protected  String fullName ;

    /* generated by template core.Attribute*/
 protected  String packageName ;

    /* generated by template core.Attribute*/
 protected  automata._symboltable.IAutomataScope spannedScope ;


    /* generated by template core.Constructor*/
 public  AutomatonSymbolTOP(String name)  {
    this.name = name;
}


    /* generated by template core.Method*/
 public  String getName ()  {
      /* generated by template methods.Get*/

return this.name;

}

    /* generated by template core.Method*/
 public  void setName (String name)  {
      /* generated by template methods.Set*/

this.name = name;

}

    /* generated by template core.Method*/
 public  automata._symboltable.IAutomataScope getEnclosingScope ()  {
      /* generated by template methods.Get*/

return this.enclosingScope;

}

    /* generated by template core.Method*/
 public  void setEnclosingScope (automata._symboltable.IAutomataScope enclosingScope)  {
      /* generated by template methods.Set*/

this.enclosingScope = enclosingScope;

}

    /* generated by template core.Method*/
 public  automata._ast.ASTAutomaton getAstNode ()  {
      /* generated by template methods.opt.Get*/

if (isPresentAstNode()) {
return this.astNode.get();
}
Log.error("0xA7003x728 AstNode can't return a value. It is empty.");
// Normally this statement is not reachable
throw new IllegalStateException();

}

    /* generated by template core.Method*/
 public  boolean isPresentAstNode ()  {
      /* generated by template methods.opt.IsPresent*/

return this.astNode.isPresent();

}

    /* generated by template core.Method*/
 public  void setAstNode (automata._ast.ASTAutomaton astNode)  {
      /* generated by template methods.opt.Set*/

this.astNode = Optional.ofNullable(astNode);

}

    /* generated by template core.Method*/
 public  void setAstNodeAbsent ()  {
      /* generated by template methods.opt.SetAbsent*/

this.astNode = Optional.empty();

}

    /* generated by template core.Method*/
 public  de.monticore.symboltable.modifiers.AccessModifier getAccessModifier ()  {
      /* generated by template methods.Get*/

return this.accessModifier;

}

    /* generated by template core.Method*/
 public  void setAccessModifier (de.monticore.symboltable.modifiers.AccessModifier accessModifier)  {
      /* generated by template methods.Set*/

this.accessModifier = accessModifier;

}

    /* generated by template core.Method*/
 public  void setFullName (String fullName)  {
      /* generated by template methods.Set*/

this.fullName = fullName;

}

    /* generated by template core.Method*/
 public  String getFullName ()  {
      /* generated by template _symboltable.symbol.NameSetter*/

  if (fullName == null) {
    fullName = determineFullName();
  }
  return fullName;
}

    /* generated by template core.Method*/
 public  void setPackageName (String packageName)  {
      /* generated by template methods.Set*/

this.packageName = packageName;

}

    /* generated by template core.Method*/
 public  String getPackageName ()  {
      /* generated by template _symboltable.symbol.NameSetter*/

  if (packageName == null) {
    packageName = determinePackageName();
  }
  return packageName;
}

    /* generated by template core.Method*/
 public  void accept (automata._visitor.AutomataSymbolVisitor visitor)  {
      /* generated by template _symboltable.AcceptTop*/

  if (this instanceof AutomatonSymbol) {
    visitor.handle((AutomatonSymbol) this);
  } else {
    throw new UnsupportedOperationException("0xA7010x888 Only handwritten class AutomatonSymbol is supported for the visitor");
  }
}

    /* generated by template core.Method*/
 protected  String determinePackageName ()  {
      /* generated by template _symboltable.symbol.DeterminePackageName*/

automata._symboltable.IAutomataScope optCurrentScope = enclosingScope;
while (optCurrentScope != null) {
final automata._symboltable.IAutomataScope currentScope = optCurrentScope;
    if (currentScope.isPresentSpanningSymbol()) {
      // If one of the enclosing scope(s) is spanned by a symbol, take its
      // package name. This check is important, since the package name of the
      // enclosing symbol might be set manually.
      return currentScope.getSpanningSymbol().getPackageName();
    } else if (currentScope instanceof automata._symboltable.AutomataArtifactScope) {
      return ((automata._symboltable.AutomataArtifactScope) currentScope).getPackageName();
    }
optCurrentScope = currentScope.getEnclosingScope();
  }
  return "";
}

    /* generated by template core.Method*/
 protected  String determineFullName ()  {
      /* generated by template _symboltable.symbol.DetermineFullName*/

  if (enclosingScope == null) {
    // There should not be a symbol that is not defined in any scope. This case should only
    // occur while the symbol is built (by the symbol table creator). So, here the full name
    // should not be cached yet.
    return name;
  }

  final Deque<String> nameParts = new ArrayDeque<>();
    nameParts.addFirst(name);

    automata._symboltable.IAutomataScope optCurrentScope = enclosingScope;

  while (optCurrentScope != null) {
  final automata._symboltable.IAutomataScope currentScope = optCurrentScope;
      if (currentScope.isPresentSpanningSymbol()) {
        // If one of the enclosing scope(s) is spanned by a symbol, the full name
        // of that symbol is the missing prefix, and hence, the calculation
        // ends here. This check is important, since the full name of the enclosing
        // symbol might be set manually.
        nameParts.addFirst(currentScope.getSpanningSymbol().getFullName());
        break;
      }

      if (!(currentScope instanceof automata._symboltable.IAutomataGlobalScope)) {
        if (currentScope instanceof automata._symboltable.AutomataArtifactScope) {
          // We have reached the artifact scope. Get the package name from the
          // symbol itself, since it might be set manually.
          if (!getPackageName().isEmpty()) {
            nameParts.addFirst(getPackageName());
          }
        } else {
          if (currentScope.isPresentName()) {
            nameParts.addFirst(currentScope.getName());
          }
          // ...else stop? If one of the enclosing scopes is unnamed,
          //         the full name is same as the simple name.
        }
  optCurrentScope = currentScope.getEnclosingScope();
  } else {
  break;
  }
    }

    return de.se_rwth.commons.Names.getQualifiedName(nameParts);
}

    /* generated by template core.Method*/
 public  automata._symboltable.IAutomataScope getSpannedScope ()  {
      /* generated by template methods.Get*/

return this.spannedScope;

}

    /* generated by template core.Method*/
 public  void setSpannedScope (automata._symboltable.IAutomataScope spannedScope)  {
      this.spannedScope = spannedScope;
      getSpannedScope().setSpanningSymbol(this);
}

}
